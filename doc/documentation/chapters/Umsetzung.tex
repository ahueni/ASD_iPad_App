\chapter{Umsetzung}
Dieses Kapitel beschreibt die Umsetzung des Produktes.
Die Nachfolgenden Abschnitte werden Schrittweise detaillierter und beschreiben den Aufbau sowie die Designentscheidungen des Softwarecodes.

\section{Einleitung}
\section{Anforderungen}
\section{Technologien}
In diesem Abschnitt wird beschrieben, welche Technologien und Tools eingesetzt wurden, um die iOS Applikation umzusetzen. Es wurde darauf geachtet, dass bewährte und von den Herstellern vorgesehene Technologien verwendet wurden.
\subsection{Entwicklungsumgebung}
Das Projekt wurde mit XCode 8.2.1 umgesetzt. Grundsätzlich, kann jede IDE verwendet werden, welche mit Swift kompatibel ist. Um das Projekt builden zu können wird zwingend ein Apple Rechner benötigt.
\subsection{Programmiersprache}
Das Projekt wurde in der Programmiersprache Swift 3 umgesetzt und ist mit iOS 10 und höher kompatibel. Es wurde darauf geachtet, dass alle Abhängigkeiten ebenfalls in Swift umgesetzt sind. Dies erleichtert die Weiterentwicklung da kein, für ungeübte Entwickler, meist schwer lesbarer Objective C Code zum Einsatz kommt.
\subsection{Abhängigkeiten}
Externe Ressourcen, wurden vorwiegend mit CocoaPods eingebunden. CocoaPods ist ein Packet Manager, mit welchem man Packete in ein bestehendes Projekt einbinden kann. Dies geschieht über ein sogenanntes Podfile, welches zum Projektumfang gehört. Dieses File beschreibt die externen Abhängigkeiten, sowie welche Version benötigt wird.

Folgende Pods wurden für das Projekt verwendet:
\begin{itemize}
\item	 pod 'Charts/Realm'
\item    pod 'Zip'
\item    pod 'PlainPing'
\item    pod 'Pulsator'
\item    pod 'FontAwesome.swift'
\end{itemize}
    
Einzig die TCP Kommunikation wurde mit externem Code gelöst, welcher nicht als Pod verfügbar ist.
\section{Architektur}

\subsection{Grobarchitektur}
Um weite Teile des Sourcecodes erneut nutzen zu können, wurde das Projekt in drei Teile aufgeteilt. Diese 3 Teile werden in den folgenden Abschnitten beschrieben.

\subsection{Core}
Der Core Ordner fasst den gesamten Code zusammen, welcher Platformunabhängig ist. Dieser Code kann auch in anderen Projekten mit ähnlicher Anwendung benutzt werden.
\subsection{Service}
Der Service Layer, kapselt einige Anfragen des App Layers an den Core Teil. Dieser Layer wird oft dazwischen gelegt, um beispielsweise Parallelität zu vermeiden. So wird im Layer beispielsweise ein Synchronized Queue benötigt, um nur ein Request nach dem Anderen an ein Spektrometer zu senden.
\subsection{iOS App}
Dieser Layer beinhaltet die eigentliche iOS App mit all Ihren typischen Eigenschaften, wie das AppDelegate und die Storyboards. In diesem Ordner werden alle Views sowie deren Controller gespeichert.

\section{Core}
\subsection{Connection}
In diesem Ordner, befindet sich die TCPManager Klasse sowie die externen Socks Dateien. Das Socks Framework kümmert sich um die Kommunikation auf TCP Ebene. Eine ausführliche Dokumentation ist unter folgendem Link zu finden: 
\newline
https://github.com/vapor/socks
\newline
Der TCP Manager ist für die Anfragen des Gerätes verantwortlich. Es ist die einzige Klasse, welche direkt mit dem Spektrometer kommuniziert. Er ist deshalb auch als Singleton umgesetzt. Mit der connect Funktion, kann eine Verbindung zum ASD Gerät hergestellt werden, danach können beliebig viele Kommandos mit sendCommand gesendet werden. Um die Verbindung zu schliessen, muss lediglich die disconnect Methode aufgerufen werden.

\subsection{Input/Output}
In diesem Kapitel, werden alle Klassen beschrieben, welche direkt Daten einlesen oder Ausgeben.
\subsubsection{File Writer}
Die Output Klassen, dienen dazu ein Indico File zu schreiben. Die Base Klasse kapselt dafür alle Schreibvorgänge. Von der Klasse File Writer, wird auf diese Methoden zugegriffen und stösst so das Schreiben in der Richtigen Reihenfolge an.
\subsubsection{File Reader}
\subsubsection{Spectrometer Parser}

\subsection{Calculations}
\subsection{Error Handling}

\section{Service}

\subsection{Instrument Store}
\subsection{Command Manager}
\subsection{File Write Manager}

\section{iOS App}
\subsection{App Delegate}
\subsection{Core Data}
\subsection{Views}

Alle ViewController sind in der Datei Main.storyboard enthalten. Dies war eine bewusste Entscheidung, um Entwicklern einen guten Überblick über den gesamten UI Ablauf zu ermöglichen. Einzig das Design für eine Zelle der Messübersichtstabelle wurde in eine eigne XIB-Datei ausgelagert.

Die Anordnung der Controls wurde im Storyboard gelöst. Kleinere Merkmale wurden jeweils im Code angepasst, indem von bestehenden Controls abgeleitet wurde.

\subsection{Controllers}

\subsubsection{Settings}

Einstellungen, welche pro Applikation verfügbar sein müssen, werden in den sogenannten UserDefaults gespeichert. Dieser Speicher, kann sämtliche serialisierbaren Objekte speichern.

\subsection{Components}
\subsection{View Store}
\subsection{Service}
\subsubsection{Validation}

Für die Validierung wurde von jedem benutzen Control eine Ableitung erstellt und und das BaseValidationControl Protokoll implementiert. Dieses Protokoll enthält ein Property isValid welches den Gültikeitszustand des Objektes enthält.

In jedem ViewController, muss nun nur noch der ValidationManager aufgerufen werden und die Hauptview übergeben werden. Dieser ValidationManager prüft nun alle Subviews, welchedas Protokoll implementieren.

Um die Validation für einen neuen ViewController hinzuzufügen, kann folgendermassen vorgangen werden:
1. Erstellen Sie einen neuen ViewController
2. Fügen Sie ein Control hinzu und leiten sie von einem bestehenden ValidationControl ab. Oder erstellen Sie eine neue Ableitung eines Controls und implementieren Sie das BaseValidationControl Protokoll.
3. Rufen Sie die validateSubViews Methode des ValidationMangers auf.


\subsubsection{File Browser}