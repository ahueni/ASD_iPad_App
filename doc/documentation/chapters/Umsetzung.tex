\chapter{Umsetzung} \label{umsetzung}
\section{Einleitung}
Dieses Kapitel beschreibt die Umsetzung des Produktes. Die nachfolgenden Abschnitte werden schrittweise detaillierter und beschreiben den Aufbau sowie die Designentscheidungen des Softwarecodes. Es soll eine zukünftige Weiterentwicklung der Software ermöglichen und für den Entwickler vereinfachen.

\section{Technologien}
In diesem Abschnitt wird beschrieben, welche Technologien und Tools eingesetzt wurden, um die iOS Applikation umzusetzen. Es wurde darauf geachtet, dass bewährte und von Apple vorgesehene Technologien verwendet werden. Die Applikation sowie der Code entsprechen der von Apple vorgegebenen Richtlinien. Weitere Informationen für die Entwicklung von Applikationen für die iOS Betriebssysteme sind direkt im \href{https://developer.apple.com/develop/}{Apple Entwicklungsbereich} zu finden.

\subsection{Entwicklungsumgebung}
Das Projekt wurde mit XCode 8.2.1 umgesetzt. Grundsätzlich kann jede \gls{ide} verwendet werden, welche mit XCode-Projektdateien kompatibel ist. Die einzige Voraussetzung, um die Applikation erfolgreich zu kompilieren, ist ein Computer mit macOS Betriebssystem.

Es können später weitere Voraussetzungen dazukommen, je nachdem wie die Applikation an die tatsächlichen Benutzer ausgeliefert werden soll.

\subsection{Programmiersprache}
Das Projekt wurde in der Programmiersprache Swift 3 umgesetzt und ist mit iOS 10.0 und höher kompatibel. Es wurde darauf geachtet, dass alle Abhängigkeiten ebenfalls in Swift umgesetzt sind. Dies erleichtert die Weiterentwicklung, da kein, für ungeübte Entwickler, meist schwer lesbarer Objective-C Code zum Einsatz kommt.

\subsection{Systemgrenzen}
Da das Projekt für die iOS Platform entwickelt wird, werden einige Funktionen bereits vom System übernommen. Folgende Funktionen werden ganz oder teilweise vom System bereitgestellt:
\begin{itemize}[noitemsep]
\item Import / Export Die Import sowie die Export Funktionen werden zu einem Grossteil vom System übernommen.
\item Core Data Objekte werden vom System verwaltet
\end{itemize}
Alle anderen Komponenten, wurden im Projekt entwickelt oder ins Projekt inkludiert.
\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.8]{images/Systemgrenze}
	\caption{Systemgrenzen}
	\label{fig:SystemBounds}
	\end{center}
\end{figure}

\subsection{Abhängigkeiten}
Externe Ressourcen und Frameworks, wurden vorwiegend mit CocoaPods eingebunden. CocoaPods ist ein Paket Manager, mit welchem man Pakete in ein bestehendes Projekt einbinden kann. Dies geschieht über ein sogenanntes Podfile, welches zum Projektumfang gehört. Dieses File beschreibt die externen Abhängigkeiten, sowie welche Version benötigt wird. CocoaPods ist kein Produkt von Apple und wird durch die Community weiterentwickelt und bereitgestellt. Sollten Updates zu Frameworks bereitstehen, können diese einfach ins Projekt integriert werden.

Folgende Frameworks wurden mit CocoaPods in das Projekt eingebunden und verwendet:
\begin{itemize}[noitemsep]
\item Charts: \href{https://github.com/danielgindi/Charts}{https://github.com/danielgindi/Charts}
\item Zip: \href{https://github.com/marmelroy/Zip}{https://github.com/marmelroy/Zip}
\item PlainPing: \href{https://github.com/naptics/PlainPing}{https://github.com/naptics/PlainPing}
\item Pulsator: \href{https://github.com/shu223/Pulsator}{https://github.com/shu223/Pulsator}
\item FontAwesome.swift: \href{https://github.com/thii/FontAwesome.swift}{https://github.com/thii/FontAwesome.swift}
\end{itemize}

Folgende Frameworks wurden direkt als Klassendateien ins Projekt eingebunden und verwendet, da sie nicht als Paket verfügbar sind.
\begin{itemize}[noitemsep]
\item Socks: \href{https://github.com/vapor/socks}{https://github.com/vapor/socks}
\end{itemize}

Das folgende Framework wurde teilweise übernommen und zusätzlich modifiziert. Es wurde auf die projektspezifischen Eigenschaften reduziert und angepasst.

\begin{itemize}[noitemsep]
\item iOS FileBrowser in Swift: \href{https://github.com/marmelroy/FileBrowser}{https://github.com/marmelroy/FileBrowser}
\end{itemize}

\subsection{Deployment}
Die Applikation wurde während der Entwicklung mit dem von Apple zur Verfügung gestellten Service \gls{testflight} ausgeliefert. Somit konnten die Prototypen und die Vorabversion auf einfache Art und Weise dem Kunden zur verfügung gestellt werden.

\gls{testflight} ermöglicht es Prototypen und Vorversionen über einen gesonderten AppStore auf registrierten iOS Geräten von bis zu 200 Testpersonen als App-Download anzubieten. Um diesen Dienst zu nutzen ist ein Apple Developer Account notwendig, mit der Integration und Konfiguration von zusätzlichen Zertifikaten.

Für eine zukünftige Weiterentwicklung und vor allem für die Auslieferung an externe Benutzer, kann die Applikation ebenfalls in den AppStore aufgenommen werden oder als B2B\footnote{Develop Custom Apps for Business: \href{https://developer.apple.com/programs/volume/b2b/}{https://developer.apple.com/programs/volume/b2b/}} Applikation vertrieben werden. In beiden Fällen benötigt der Entwickler aber einen gültigen Apple Developer Account.

\newpage

\section{Architektur}

\subsection{Grobarchitektur}
Um weite Teile des Quellcodes erneut nutzen zu können, wurde das Projekt in die drei Teile Core, Service und iOS App aufgeteilt. Die Layer wurden nach bestimmten Kriterien aufgetrennt, diese werden in den nachfolgenden Kapiteln genau beschrieben.

\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.35]{images/SA_BigPicture} 
	\caption{Layeraufteilung der Grobarchitektur}
	\label{fig:SALayers}
	\end{center}
\end{figure}

\subsection{Core}
Der Core fasst den gesamten Code zusammen welcher plattformunabhängig ist. Dieser Code könnte in weiteren Projekten eingesetzt werden, die auf der Programmiersprache Swift aufbauen. Klassen im Core-Layer verwenden nur Grundkomponenten von Swift und könnten so auch auf einem anderen Betriebssystem eingesetzt werden, das Swift unterstützt.

\subsection{Service}
Der Service-Layer kapselt Anfragen des iOS-Layers an den Core. Dieser Layer wurde verwendet um Parallelität zu vermeiden. Der Service-Layer beinhaltet Manager-Klassen, die Aufrufe an den Core mit einer Synchronized-Queue bearbeiten und weiterleiten. Somit ist garantiert, dass niemals zwei Befehle gleichzeitig oder überlappend an das \gls{spectrometer} gesendet werden. Auch das Schreiben von nummerierten Messdateien ins Dateisystem kann durch ein FileManager so gekapselt werden.

Klassen im Service-Layer unterscheiden sich durch ein weiteres Kriterium vom Core. Sie können nur auf Plattformen von Apple eingesetzt werden, da sie gewisse Importe benötigen die nicht in der Swift Basis enthalten sind. Der Service-Layer könnte im gesamten Programmierumfeld von Apple (macOS, iOS, watchOS, tvOS) eingesetzt werden, nicht aber ausserhalb.

\subsection{iOS App}
Dieser Layer (Im Xcode wird dieser Ordner als Spectrometer geführt) beinhaltet die eigentliche iOS App mit all ihren typischen Eigenschaften wie das AppDelegate, die Storyboards und die ViewController. Zusätzlich wurden noch eigene View Komponenten erstellt die ebenfalls in diesem Layer enthalten sind.

\section{Core}

\subsection{Models}
In diesem Ordner werden sämtliche Datenstrukturen definiert die in Verbindung mit dem Spektrometer, den INI-Dateien oder Indico-Dateien verwendet werden. Es wurde darauf geachtet, diese möglichst erweiterbar zu gestalten. Es gibt wenn möglich eine Basis-Klasse, welche die immer gleichen Grundstrukturen bei Spektraldaten oder Indico-Dateien implementiert. Die Ableitungen spezialisieren dann die effektiven Datentypen.
Diese Aufteilung ermöglicht es einem Entwickler, einfach einen neuen Indico-Standart oder ein Rückgabetyp eines zusätzlichen Spektrometers zu erstellen.

\subsubsection{Command}
Der Command wird verwendet, um genormte Anfragen ans Spektrometer zu senden. Für jeden Command wurde eine Grösse definiert, die vom erwarteten Datentyp abhängt. Somit kann der TCP Manager jeweils entscheiden, wann alle Daten empfangen wurden.

\subsubsection{SpectralData}
In diesem Ordner wurden alle Datentypen definiert, die vom Spektrometer empfangen werden können. Die genauen Grössen und vorhandenen Felder wurden dem ASD Developer Guide entnommen. Dieser ist im \hyperref[subsection:developersGuide]{Anhang} erwähnt. Die meisten Befehle haben ihren bestimmten Rückgabetyp. Einige verwandte Befehle verwenden jedoch auch den gleichen Rückgabetyp.

\subsubsection{IndicoFile}
In diesem Ordner wurde der Datentyp für das Indico-Dateiformat definiert. Die Basisklasse \verb=IndicoFileBase= repräsentiert genau eine INI-Datei, die für die Spektrometer-Konfiguration verwendet wird. Die Ableitung \verb=IndicoFile7= repräsentiert die vollständige Datei mit allen Spektraldaten. Der Inhalt der Dateien wird in der Abbildung \ref{fig:MeasurementFiles} genau dargestellt.

\subsection{Connections} \label{sec:connection}
In diesem Ordner, befindet sich die TCP-Manager Klasse sowie die externen Socks Dateien. Das Socks Framework kümmert sich um die Kommunikation auf TCP Ebene. Für die Integration wurde nicht CocoaPods verwendet, weshalb die Klassen direkt in den Ordner kopiert wurden.

Der TCP-Manager ist für die Anfragen an das Spektrometer verantwortlich. Es ist die einzige Klasse, welche direkt mit dem \gls{spectrometer} kommuniziert und ist deshalb als Singleton umgesetzt. Mit der Methode \verb=connect(internetAdress: InternetAddress)= kann eine Verbindung zum \gls{spectrometer} hergestellt werden, danach können beliebig viele Kommandos mit \verb=sendCommand(command: Command)= gesendet werden. Um die Verbindung zu schliessen, muss lediglich die \verb=disconnect()= Methode aufgerufen werden.

\subsection{Input/Output}
In diesem Kapitel werden alle Klassen beschrieben, welche direkt Dateien einlesen, Daten empfangen oder Dateien schreiben.

\subsubsection{File Writer}
Die Output Klassen dienen dazu, eine Indico-Datei zu schreiben. Die Basis Klasse kapselt dafür alle Schreibvorgänge. Von der Klasse \verb=FileWriter= wird auf diese Methoden zugegriffen und stösst so das Schreiben in der richtigen Reihenfolge an. Von aussen kann lediglich gewählt werden, welche der drei Messmethoden geschrieben werden soll: Raw, Reflectance oder Radiance.
Um die Applikation um einen neuen Writer zu erweitern, muss lediglich vom \verb=BaseWriter= abgeleitet werden und eine eigene \verb=write()= Methode implementiert werden. Diese neue Klasse kann die von der Basis bereitgestellten Methoden nutzen oder um weitere ergänzen.

\subsubsection{File Reader und Spectrometer Parser} \label{sec:raderandparser}
Die Reader- und Parserklassen bauen alle auf der selben Basis auf. In der \verb=BaseSpectrumInput= Klasse sind alle Funktionen realisiert, um aus Byte-Werten die entsprechenden Datentypen zu parsen. In den konkreten Implementierungen müssen diese dann nur in der richtigen Reihenfolge aufgerufen und den entsprechenden Feldern zugewiesen werden.

Durch die inkonsistente Implementierung von der Firma ASD gibt es immer wieder verwirrende Stellen die gesondert implementiert werden müssen. Als Beispiele sind hier Strings zu nennen, die zum Teil als prefixed, null-terminiert oder aber mit fixer Länge in der gleichen Datei implementiert wurden. Teilweise werden Float- oder Doublewerte in derselben Antwort vom Gerät einmal im "Little-Endian"-und dann wieder im "Big-Endian"-Format codiert.

\subsection{Calculations}
Der Ordner Calculations enthält lediglich die Klasse \verb=SpectrumCalculator= welche nur statische Funktionen enthält. Diese dienen der Berechnung der Reflektanz sowie der Radianz. Ausserdem beinhaltet die Klasse noch eine Methode um eine Dark Correction auf einem übergebenen Spektrum durchzuführen.
\subsection{Error Handling}
Fehler werden nur abgefangen wenn sie erwartet werden. Dies bedeutet es gibt kein allgemeine Fehlerbehandlung, da dies die Applikation in einen inkonsistenten Zustand bringen würde. Das ErrorHandling wurde nur eingebaut bei der Kommunikation mit externen Ressourcen, sprich dem ASD Gerät oder bei Input/Output Operationen. Bei der Entwicklung, wurde festgestellt, dass die Daten des Spektrometers nicht zwingend korrekt sein müssen. In diesem Fall, wird beim Parsen ein \verb=SpektrometerError= geworfen. Hier am Beispiel, des Saturation Enums:

\begin{lstlisting}
enum Saturation: Int {
    case NoSaturation = 0
    case Saturated = 1
    init(fromRawValue: Int) throws {
        if let value = Saturation(rawValue: fromRawValue) {
            self = value
        } else {
            throw SpectrometerError(message: "Could not parse saturation
            of spectrum.", kind: .parsingError)
        }
    }
}
\end{lstlisting}

Das \verb=SpectrometerError= Objekt sieht wie folgt aus:

\begin{lstlisting}
struct SpectrometerError: Error {
    enum ErrorKind {
        case connectionError
        case readError
        case parsingError
    }
    let message: String
    let kind: ErrorKind
}
\end{lstlisting}

Der \verb=CommandManager= ist zuständig diese Errors korrekt zu behandeln. Dies geschieht, indem er sie bei privaten Methoden weitergibt und bei öffentlichen Funktionen abfängt. Jede öffentliche Methode des \verb=CommandManager= besitzt zwei Callback Parameter. Jeweils ein Callback für den erfolgreichen durchlauf der Methode und ein Fehler Callback. Wird ein Fehler abgefangen, wird der Fehler Callback aufgerufen, ansonsten der success Callback. Folgend die aquire Methode als Beispiel:

\begin{lstlisting}
func aquire(samples, successCallBack:(spectrum), errorCallBack:(error) {
    var spectrum: FullRangeInterpolatedSpectrum!
        do {
            try serialQueue.sync {
                spectrum = try internalAquire(samples: samples)
            }
        successCallBack(spectrum)
    } catch let error {
        errorCallBack(error)
    }
}
\end{lstlisting}

Nun kann der Aufrufer entscheiden, was er bei einem Fehler oder einem korrekten Aufruf machen möchte. Dies geschieht in der Regel in der ViewController Methode. Falls beim Parsen ein Fehler auftritt, wechselt die Applikation auf die Verbindungsview und trennt die TCP Verbindung zum Spektrometer. So ist sichergestellt, das keine falschen Daten verarbeitet oder angezeigt werden.

\section{Service}

\subsection{Instrument Store}
Im \verb=InstrumentStore= werden alle Objekte gespeichert, auf welche global zugegriffen werden muss und die nichts mit der Benutzeroberfläche zu tun haben. Um zu garantieren, dass die Variablen nur einmal existieren, ist die Klasse als Singleton umgesetzt.

\subsection{Command Manager}
Der \verb=CommandManager= übernimmt die Funktion, alle Kommandos in der korrekten Reihenfolge abzuarbeiten. Der \verb=CommandManager= bietet Methoden für alle gängigen \gls{spectrometer} Kommandos an. Wird eine dieser Methoden aufgerufen, wird die Anfrage an eine synchrone Queue übergeben welche nach dem First-In-First-Out Prinzip die Anfragen abarbeitet. So ist sichergestellt, dass ein Kommando erst an das \gls{spectrometer} gesendet wird, wenn alle vorherigen abgearbeitet sind.
\newline
Der \verb=CommandManager= besitzt eine Methode, um einen Callback zu erhalten, sobald dieser an der Reihe ist. Dies wird benötigt, um nach dem beenden des AquireLoops festestellen zu können, wann der letzte Command in der Queue abgearbeitet wurde. Die Methode sieht wie folgt aus:

\begin{lstlisting}
func addCancelCallback(message: String? = nil, callBack: () -> Void)
{
	serialQueue.sync
	{
		callBack()
	}
}
\end{lstlisting}

\subsection{File Write Manager}
Der \verb=FileWriteManager= funktioniert ähnlich wie der \verb=CommandManager=. Er übergibt dem \verb=FileWriter= Aufträge ebenfalls in einer synchronen Warteschlange und arbeitet diese ab. Dazu kümmert sich der \verb=FileWriteManager= auch um die korrekte Benennung der ASD Files. Dies geschieht, indem er den höchsten geschriebenen prefix eines Files im Pfad mit dem selben Basisnamen findet und diesen dann entsprechend erhöht.
\newline
Der \verb=FileWriteManager= verfügt wie der \verb=CommandManager= über eine Callback Methode, welche die Callback Methode aufruft, sobald das letzte File in der Queue geschrieben wurde.

\section{iOS App} \label{sec:iosApp}

\subsection{App Delegate}
Das \verb=AppDelegate= ist der Einstiegspunkt jeder iOS Applikation. Darin wird beschrieben, wie der Prozess aus verschiedenen Zuständen abläuft (Stopped, Paused, Notified). Im \verb=AppDelegate= können auch applikationsweite Designanpassungen vorgenommen werden. So kann eine Schriftart für \verb=TabBarItems= oder für die \verb=NavigationBar= definiert werden.

Das \verb=AppDelegate= wird ebenfalls aufgerufen, wenn eine externe Datei erfolgreich importiert wurde. Das Importieren selbst wird vom Betriebssystem übernommen. In diesem Projekt wird auf der aktuellen View eine Meldung angezeigt, dass eine Datei erfolgreich importiert wurde.

Die Importfunktion hat beim importieren aus 

\subsection{Core Data}
Core Data ist ein System, um Daten auf dem Gerät zu speichern. Es dient nicht als Datenbankersatz, kann aber für einfache Speicherungen genutzt werden. Durch die Integration in XCode, lassen sich Speicherklassen einfach modellieren und einsetzen. Core Data Einstellungen können in \verb=xcdatamodeld= Klassen vorgenommen werden. Dabei können Datentypen sowie die Relationen der einzelnen Records definiert werden. Weitere Informationen befinden sich auf der offiziellen Entwicklerseite von Apple im \href{https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData}{Core Data Programming Guide}

\begin{alertinfo}{Vorsicht}
	Core Data Zugriffe sind vergleichsweise langsam und sollten daher nicht in Schleifen verwendet werden.
\end{alertinfo}

\subsection{Views}

Alle ViewController sind in der Datei \verb=Main.storyboard= enthalten. Einzig das Design für zwei TableView-Zellen wurde in separate XIB-Dateien ausgelagert. Dies war eine bewusste Entscheidung, um Entwicklern einen guten Überblick über den gesamten Ablauf in der Benutzeroberfläche zu ermöglichen. Ein ViewController wird von iOS eigenhändig instanziiert, sobald er von einer anderen View aufgerufen wird. Dies ermöglicht es, Verlinkungen der Views direkt im Storyboard umzusetzen.

Die Anordnung der Controls wurde im Storyboard gelöst. Kleinere Merkmale wurden jeweils im Code angepasst, indem diese direkt beim Laden eines ViewControllers vorgenommen wurden.

Die gesamte Ausrichtung und Anpassung auf unterschiedliche Bildschirmgrössen wurde ebenfalls im Storyboard mit \gls{autolayout} gelöst. Einzige Ausnahme ist der \verb=SpectrometerViewController=. \gls{autolayout} ermöglicht keine Unterscheidung des Portrait oder Landscape Modus bei iPads. Diese Unterscheidung und das Verhalten wurden direkt im Code umgesetzt.

\subsection{Controllers}

\subsubsection{Connections}
Die zwei ViewControllers \verb=AddEditConnectionViewController= und \verb=ConnectionViewController= dienen beim Start der Applikation, dazu neue Spektrometer hinzuzufügen oder bestehende zu bearbeiten. Diese ViewController interagieren direkt mit dem Storyboard und den dazugehörigen Views. Die Klasse \verb=SpectrometerConfigTableViewCell= dient als Hilfsklasse, um die Tabelleneinträge der Spektrometertabelle zu gestalten und mit dem Code zu verknüpfen.

\subsubsection{Spectrometer}

In der Klasse \verb=SpectrometerViewController= sind alle Funktionen und Verknüpfungen für die Hauptansicht umgesetzt. Diese ist in der Lage, wenn alle Voraussetzungen erfüllt sind, zwischen Raw, Reflectance und Radiance zu wechseln und die berechneten Daten direkt im Liniendiagramm darzustellen. Das kontinuierliche akquirieren neuer Messwerte wird durch eine Endlosschleife immer weitergeführt bis die Abbruchbedingung eintritt. Weiter ist die Klasse für folgende Aktionen und Darstellungen zuständig:

\begin{itemize}[noitemsep]
\item Dark Current oder White Reference per Button auslösen.
\item Die entsprechenden Timer wieder zurücksetzen und aktualisieren.
\item Eine Optimierung des Spektrometers durchführen.
\item Messung initiieren, sprich die Anzeige der PopUp View für den Messablauf.
\item Verbindung zum Spektrometer trennen.
\end{itemize}

\subsubsection{MeasurementSeries}

In dieser Gruppe befindet sich die gesamte Logik, um Messungen in fest vorgegebenen Messprotokollen auszuführen. In der nachfolgenden Tabelle sind die drei Messprotokolle detailliert beschrieben.

\begin{center}

	\bgroup
	\def\arraystretch{1.7}
	\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
	\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}
	\renewcommand\cellgape{\Gape[4pt]}
	
    \begin{tabular}{ c | M{4cm} | M{4cm} | M{4cm} }
    
    \textbf{Modus} & \textbf{Schritt 1} & \textbf{Schritt 2} & \textbf{Schritt 3} \\ \hline
    
    \textbf{Raw} & \makecell{Target \\ $[1-n] (0-x) \{DC\}$ } &  &  \\ \hline
    \textbf{Reflectance} & \makecell{White Reference (Ref) \\ $[1] (0-x)$ } & \makecell{Target \\ $[1-n] (0-x)$ } &  \\ \hline
    \textbf{Radiance} & \makecell{White Reference (Rad) \\ $[0-n] (0-x) \{FO\}$ } & \makecell{Target \\ $[1-n] (0-x) \{FO\}$ } & \makecell{White Reference \\ $[0-n] (0-x) \{FO\}$ } \\
    
    \end{tabular}
    \egroup
    
\end{center}

Erläuterungen zur Tabelle: 
\begin{itemize}[noitemsep]
\item $[n]=$ Anzahl Messungen die durchgeführt werden.
\item $(x)=$ Verzögerungen zwischen den Messungen.
\item $\{DC\}=$ Dark Current Correction nicht durchführen
\item $\{FO\}=$ Fore Optic einstellbar
\end{itemize}

\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=1.0]{images/MeasurementSeriesArcitecture} 
	\caption{Feinarchitektur der Messreihen}
	\label{fig:MeasurementSeriesArcitecture}
	\end{center}
\end{figure}

Die Schritte 1-3 im Messprotokoll werden immer nacheinander durchgeführt. Ist beim Messprotokoll kein weiterer Schritt mehr vorhanden, führt dies automatisch zum Abschluss der Messung.

In der Abbildung \ref{fig:MeasurementSeriesArcitecture} wird das ganze Zusammenspiel der Klassen dargestellt. Aus dieser Darstellung ist auch ersichtlich, dass für die White Reference Messung in den zwei Protokollen Reflectance und Radiance eine andere Klasse zur Ausführung kommt. Dies hat vor allem einen Grund, da die Views unterschiedliche Komponenten anbieten (ProgressBar), müssen sie getrennt verwaltet werden.

Um ein zusätzliches Messprotokoll umzusetzen, kann nun auf bestehende Komponenten zurückgegriffen werden oder für neue eine zusätzliche Klasse mit View erstellt werden. Zu beachten ist, dass bei einem zusätzlichen Messprotokoll auch eine neue Einstellungs-Klasse nötig wird.

Die Klassen Start, Settings und Finish werden hier nicht genauer erläutert, diese haben keinen grossen funktionellen Anteil und verwalten vor allem Einstellungen. Der genaue Ablauf in den MeasurementModals ist etwas komplizierter, folgt aber immer der Implementierung in der Basis Klasse. Die Grundidee ist, ein Liniendiagramm darzustellen, das fortlaufend immer aktuelle Messwerte beim Spektrometer anfordert. Entscheidet sich der Benutzer nun Messungen durchzuführen, werden die Messwerte zusätzlich abgefangen und entsprechend verarbeitet. Für die Darstellung werden die Messwerte entsprechend berechnet. In die effektiven Messdaten (Indico Dateien) werden aber nur die gemessenen Raw-Daten geschrieben. Die wichtigsten Komponenten der Klasse \verb=BaseMeasurementAquire= werden nachfolgend genauer beschrieben.

Die Funktion \verb=startAquire()= wird direkt nach der Instanziierung der jeweiligen Klasse in der Methode \verb=viewDidLoad()= aufgerufen. Mit diesem Aufruf beginnt das kontinuierliche Anfordern der Messdaten auf dem Spektrometer. Die Daten werden dann anhand der nachfolgend beschriebenen Implementierung verarbeitet und angezeigt.

\begin{lstlisting}
func startMesurement()
\end{lstlisting}
Diese Methode übernimmt alle Funktionalitäten sobald der Benutzer die Messwerte auch wirklich abspeichern möchte. In dieser Methode werden dann auch die entsprechenden UI Komponenten initialisiert, aktiviert oder deaktiviert.

\begin{lstlisting}
func finishedMeasurement()
\end{lstlisting}
Sobald die eingestellte Anzahl an Messungen erreicht ist, wird diese Methode aufgerufen. Das weitere Abspeichern und Abzweigen von Messdaten wird automatisch gestoppt. Diese Methode kann überschrieben werden, sollten zum Messungsende weitere Schritte notwendig sein.

\begin{lstlisting}
func handleRawSpectrum(currentSpectrum: FullRangeInterpolatedSpectrum)
\end{lstlisting}
Diese Methode \textbf{muss} von einer konkreten Implementierung überschrieben werden. Sie verarbeitet die Raw-Messdaten, dies bedeutet, die Daten werden entweder zwischengespeichert oder direkt in eine Datei geschrieben. Dies ist je nach Messprotokoll unterschiedlich.

\begin{lstlisting}
func viewCalculationsOnCurrentSpectrum(currentSpectrum: FullRangeInte...)
\end{lstlisting}
Für die Diagrammanzeige müssen jeweils noch Berechnungen am Spektrum durchgeführt werden. Diese Methode \textbf{muss} ebenfalls zwingend überschrieben werden um die gewünschte Funktionalität zu garantieren.

\begin{lstlisting}
func handleChartData(chartData: [Float])
\end{lstlisting}
Diese Methode \textbf{muss} ebenfalls zwingend überschrieben werden. Je nach Messprotokoll sollen Messdaten der vorherigen Messung noch bestehen bleiben oder gelöscht werden. Dieses Verhalten wird dadurch gesteuert. Die Methode verwaltet den \verb=LineChartDataContainer=. In diesem werden die Chart-Daten entsprechend zwischengespeichert, die nach jedem Anfordern der Messdaten neu aktualisiert werden.

\subsubsection{Measurements}

Der \verb=MeasurementTableViewControllerViewController= und \verb=MeasurementDetailViewController= implementieren die Funktionalität, die durchgeführten Messungen in einer Ordnerstruktur anzusehen. Die Table View ist von den erstellten Basiskomponenten \=FileBrowser= abgeleitet und implementiert eine spezielle \verb=MeasurementTableViewCell=. Diese bietet zusätzlich zur Navigation noch einen Export an.

Will der Benutzer einen Ordner oder eine Datei exportieren, wird ein \verb=DiskFileAcitivtyItem= erstellt und das Popup mit den Exportmöglichkeiten eingeblendet. Sobald der sein Exportziel ausgewählt hat, wird die Methode \verb=activityViewController()= aufgerufen. Um einen gesamten Ordner zu exportieren, wird zuerst eine temporäre ZIP Datei erstellt, die nach erfolgreichem Export direkt wieder gelöscht wird. Eine ASD Datei kann direkt exportiert werden.

\subsubsection{Settings}

Einstellungen, welche pro Applikation verfügbar sein müssen, werden in den sogenannten UserDefaults gespeichert. Dieser Speicher kann sämtliche serialisierbaren Objekte speichern.

\subsection{Components}

Die Erstellung von eigenen View Components, also Ableitungen von bestehenden Komponenten, hat in einem iOS Projekt den Vorteil, dass diese dann direkt im Storyboard verwendet und angezeigt werden können. So erhält man bereits bei der Entwicklung einen Eindruck über Anordnung, Farben und Grössenverhältnisse. Die Komponenten können mit eigenen Feldern ergänzt werden, die dann bequem im Storyboard eingestellt werden können.

Folgende Komponenten für das UI wurden selbst erstellt.
\begin{itemize}[noitemsep]
\item SpectrometerTabBarItem: Das Icon kann direkt im Storyboard definiert werden.
\item UIRoundBorderdView: Einen ViewContainer mit einstellbaren abgerundeten Ecken.
\item File- und Pathselects: Diese Komponenten rufen selbständig den Filebrowser auf und bieten ebenfalls Validierung an. Weiter gibt es eine Methode um mit dem selektierten File oder Path umzugehen.
\item TextFields: Verschiedene Varianten wie Required, Optional, IP oder Port, die zusätzlich noch mit einem Icon versehen werden können.
\item TitleSection: Wird in allen Modals im Titel Bereich verwendet.
\item Buttons: RoundedColorButton, RadioButon oder LoadingButton die ebenfalls direkt im Storyboard abgeändert werden können.
\item CustomChart: Anpassung der Chart View an die projektspezifischen Bedürfnisse.
\item CustomProgressBar: Eine spezielle ProgressBar, die bei den Messungen zum Einsatz kommt.
\item SettingsBox: Wird in den Messprotokoll-Einstellungen verwendet und stellt eine graphische Box dar.
\item SelectFiberOptic: Ermöglicht alle verfügbaren FiberOptics einzublenden und anschliessend eine zu selektieren.
\end{itemize}


\subsection{View Store}
Der \verb=ViewStore= dient wie der \verb=InstrumentStore= zum Speichern weiter benötigter Variablen. Er ist ebenfalls als Singleton implementiert. Im Gegensatz zum InstrumentStore enthält der ViewStore aber nur Elemente, welche UI relevant sind. Darin wird beispielsweise gespeichert, ob gerade eine Aquire-Schleife läuft.

\subsection{Service}

\subsubsection{Validation}
Für die Validierung wurde von jedem benutzten Control eine Ableitung erstellt und das \verb=BaseValidationControl= Protokoll implementiert. Dieses Protokoll enthält ein Feld \verb=isValid= welches den Gültigkeitszustand des Objektes enthält.
\newline\newline
Das Protokoll sieht wie folgt aus:

\begin{lstlisting}
protocol BaseValidationControl {
    var isValid : Bool {get}
    func validate()
}
\end{lstlisting}

Ein Beispiel für die Implementierung des Protokolls ist das PortTextField:

\begin{lstlisting}
class PortTextField : BaseTextField {
    //Init Code
    override var isValid: Bool {
        get {
            let port = Int(text!)
            return port != nil && port! >= 0 && port! <= 65535
        }
    }
}
\end{lstlisting}

In jedem ViewController muss nur noch der \verb=ValidationManager= aufgerufen werden und die Haupt-View übergeben werden. Dieser \verb=ValidationManager= prüft nun alle Sub-Views, welche das \verb=BaseValidationControl= Protokoll implementieren.
Dieser Aufruf sieht folgendermassen für die Validierung der gesamten View aus:
\begin{lstlisting}
ValidationManager.sharedInstance.validateSubViews(view: self.view)
\end{lstlisting}


\subsubsection{File Browser}
Der File Browser ist eine Abwandlung von der Komponente \textbf{iOS FileBrowser in Swift}, welche unter folgendem Link zu finden ist: \href{https://github.com/marmelroy/FileBrowser}{https://github.com/marmelroy/FileBrowser}

Diese Komponente wurde auf die eigenen Bedürfnisse angepasst. Der File Browser, besteht jeweils aus einem Container sowie einem integrierten \verb=TableViewController=. Zusammen bilden sie ein einfaches System, in welchem der Benutzer eine Datei oder einen Pfad selektieren kann.

Der File Browser kann einfach erweitert werden, indem ein neuer Container erstellt wird. Dieser Container muss von \verb=FileBrowserContainerViewController= ableiten und kann diesen um neue Controls ergänzen. Um das Verhalten der inneren Tabelle zu ändern, kann eine Klasse erstellt werden, welche von \verb=BaseFileBrowserTableViewController= ableitet. Dies wird im Projekt bereits genutzt, um den Container mit der Funktionalität der Ordnerwahl sowie der Ordnererstellung zu erweitern.

Folgend ein Beispiel, das für die Ordnerauswahl überschrieben wurde:

\begin{lstlisting}

class DirectoryBrowserContainerViewController : FileBrowserContainerViewController
{
    //Init
    
    @IBAction func ChooseDirectoryButtonClicked(_ sender: UIBarButtonItem) {
        didSelectFile!(DiskFile(url: selectedPath))
        dismiss(animated: true, completion: nil)
    }
}

class DirectoryBrowserTableViewController: FileBrowserTableViewController 
{
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let selectedFile = getFileForIndexPath(indexPath: indexPath)
        if(selectedFile.isDirectory)
        {
            // open folder
        }
        else
        {
            // deselect row
        }
    }
}
\end{lstlisting}

