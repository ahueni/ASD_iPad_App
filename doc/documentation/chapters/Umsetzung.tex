\chapter{Umsetzung}
Dieses Kapitel beschreibt die Umsetzung des Produktes.
Die Nachfolgenden Abschnitte werden Schrittweise detaillierter und beschreiben den Aufbau sowie die Designentscheidungen des Softwarecodes.

\section{Einleitung}
\section{Anforderungen}
\section{Technologien}
In diesem Abschnitt wird beschrieben, welche Technologien und Tools eingesetzt wurden, um die iOS Applikation umzusetzen. Es wurde darauf geachtet, dass bewŠhrte und von den Herstellern vorgesehene Technologien verwendet wurden.
\subsection{Entwicklungsumgebung}
Das Projekt wurde mit XCode 8.2.1 umgesetzt. GrundsŠtzlich, kann jede IDE verwendet werden, welche mit Swift kompatibel ist. Um das Projekt builden zu kšnnen wird zwingend ein Apple Rechner benštigt.
\subsection{Programmiersprache}
Das Projekt wurde in der Programmiersprache Swift 3 umgesetzt und ist mit iOS 10 und hšher kompatibel. Es wurde darauf geachtet, dass alle AbhŠngigkeiten ebenfalls in Swift umgesetzt sind. Dies erleichtert die Weiterentwicklung da kein, fŸr ungeŸbte Entwickler, meist schwer lesbarer Objective C Code zum Einsatz kommt.
\subsection{AbhŠngigkeiten}
Externe Ressourcen, wurden vorwiegend mit CocoaPods eingebunden. CocoaPods ist ein Packet Manager, mit welchem man Packete in ein bestehendes Projekt einbinden kann. Dies geschieht Ÿber ein sogenanntes Podfile, welches zum Projektumfang gehšrt. Dieses File beschreibt die externen AbhŠngigkeiten, sowie welche Version benštigt wird.

Folgende Pods wurden fŸr das Projekt verwendet:
\begin{itemize}
\item	 pod 'Charts/Realm'
\item    pod 'Zip'
\item    pod 'PlainPing'
\item    pod 'Pulsator'
\item    pod 'FontAwesome.swift'di
\end{itemize}
    
Einzig die TCP Kommunikation wurde mit externem Code gelšst, welcher nicht als Pod verfŸgbar ist. Mehr dazu unter dem Abschnitt \hyperref[sec:Connection]{Connection}.
\section{Architektur}

\subsection{Grobarchitektur}
Um weite Teile des Sourcecodes erneut nutzen zu kšnnen, wurde das Projekt in drei Teile aufgeteilt. Diese 3 Teile werden in den folgenden Abschnitten beschrieben.

\includegraphics[scale=0.41]{images/SA_BigPicture}

\subsection{Core}
Der Core Ordner fasst den gesamten Code zusammen, welcher PlatformunabhŠngig ist. Dieser Code kann auch in anderen Projekten mit Šhnlicher Anwendung benutzt werden.
\subsection{Service}
Der Service Layer, kapselt einige Anfragen des App Layers an den Core Teil. Dieser Layer wird oft dazwischen gelegt, um beispielsweise ParallelitŠt zu vermeiden. So wird im Layer beispielsweise ein Synchronized Queue benštigt, um nur ein Request nach dem Anderen an ein \gls{spectrometer} zu senden.
\subsection{iOS App}
Dieser Layer beinhaltet die eigentliche iOS App mit all Ihren typischen Eigenschaften, wie das AppDelegate und die Storyboards. In diesem Ordner werden alle Views sowie deren Controller gespeichert.

\section{Core}
\subsection{Connection}
\label{sec:Connection}
In diesem Ordner, befindet sich die TCPManager Klasse sowie die externen Socks Dateien. Das Socks Framework kŸmmert sich um die Kommunikation auf TCP Ebene. Eine ausfŸhrliche Dokumentation ist unter folgendem Link zu finden: 
\newline
https://github.com/vapor/socks
\newline
Der TCP Manager ist fŸr die Anfragen des GerŠtes verantwortlich. Es ist die einzige Klasse, welche direkt mit dem \gls{spectrometer} kommuniziert. Er ist deshalb auch als Singleton umgesetzt. Mit der connect Funktion, kann eine Verbindung zum ASD GerŠt hergestellt werden, danach kšnnen beliebig viele Kommandos mit sendCommand gesendet werden. Um die Verbindung zu schliessen, muss lediglich die disconnect Methode aufgerufen werden.

\subsection{Input/Output}
In diesem Kapitel, werden alle Klassen beschrieben, welche direkt Daten einlesen oder Ausgeben.
\subsubsection{File Writer}
Die Output Klassen, dienen dazu ein Indico File zu schreiben. Die Base Klasse kapselt dafŸr alle SchreibvorgŠnge. Von der Klasse File Writer, wird auf diese Methoden zugegriffen und stšsst so das Schreiben in der Richtigen Reihenfolge an. Von aussen kann lediglich gewŠhlt werden, welche der 3 Messmethoden geschrieben werden soll: Raw, Reflectance oder Radiance.
\newline
Um die Applikation um einen neuen Writer zu erweitern, muss lediglich vom BaseWriter abgeleitet werden und eine eigene write Methode implementiert werden. Diese neue Klasse, kann die vom BaseWriter bereitgestellten Methoden nutzen oder um weitere ergŠnzen.
\subsubsection{File Reader}

\subsubsection{Spectrometer Parser}

\subsection{Calculations}
Der Ordner Calculations enthŠlt lediglich die Klasse SpectrumCalculator welche nur statische Funktionen enthŠlt. Diese dienen der Berechnung der Reflektanz sowie der Radianz. Ausserdem beinhaltet die Klasse noch eine Methode um eine Dark Correction auf einem Ÿbergebenen Spetrum durchzufŸhren.
\subsection{Error Handling}

\section{Service}

\subsection{Instrument Store}
Im Instrument Store, werden alle Objekte gespeichert, auf welche global zugegriffen werden muss und nichts mit dem Userinterface zu tun haben. Um zu garantieren, dass die Variablen nur einmal existieren, ist die Klasse als Singleton umgesetzt.
\subsection{Command Manager}
Der Command Manager Ÿbernimmt die Funktion alle Kommandos in der korrekten Reihenfolge abzuarbeiten. Der Command Manager bietet Methoden fŸr alle gŠngigen \gls{spectrometer} Kommandos an. Wird eine dieser Methoden aufgerufen, Ÿbergibt der Command Manager die Anfrage an eine synchrone Queue welche nach dem First-In-First-Out Prinzip die Anfragen abarbeitet. So ist sichergestellt, dass ein Kommando erst an das \gls{spectrometer} gesendet wird, wenn alle vorherigen abgearbeitet sind.
\subsection{File Write Manager}
Der Write Manager funktioniert Šhnlich wie der Command Manager. Er Ÿbergibt write Anfragen ebenfalls einer synchronen Warteschlange und arbeitet diese ab. Dazu kŸmmert sich der FileWriteManager auch um die korrekte Benennung der ASD Files. Dies geschieht, indem er den hšchsten geschriebenen prefix eines Files im Pfad findet und diesen dan entsprechend erhšht.

\section{iOS App}
\subsection{App Delegate}
Das App Delegate ist das eigentliche Einstiegsfile jeder iOS Applikation. Darin wird beschrieben, wie der Prozess aus verschiednen ZustŠnden ablŠuft (Stopped, Paused, Notified). Im AppDelegate werden auch Applikationsweite DesignsŠnderungen vorgenommen, so wird beispielsweise die Schriftart fŸr die gesamte Applikation gesetzt.
\newline
AppDelegate wird ebenfalls aufgerufen, wenn ein File erfolgreich importiert wurde. Das importieren selbst, wird vom Betriebsystem Ÿbernommen. In diesem Projekt wird auf der aktuellen View eine Meldung angezeigt, dass ein File erfolgreich importiert wurde.
\subsection{Core Data}
Core Data ist ein System, um Daten auf dem GerŠt zu speichern, es dient nicht als Datenbank ersatz, kann aber fŸr einfache Speicherungen genutzt werden. Durch die Integration in XCode, lassen sich Speicherklassen einfach modellieren und einsetzen. Core Data Einstellungen kšnnen in xcdatamodeld Klassen vorgenommen werden. Dabei kšnnen Datentypen sowie die Relationen der einzelnen Records definiert werden. Weitere Informationen finden sich auf der offiziellen Entwicklerseite von Apple: https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/index.html

\begin{alertinfo}{Vorsicht}
	Core Data Zugriffe sind vergleichsweise langsam und sollten daher nicht in Schleifen verwendet werden.
\end{alertinfo}

\subsection{Views}

Alle ViewController sind in der Datei Main.storyboard enthalten. Dies war eine bewusste Entscheidung, um Entwicklern einen guten †berblick Ÿber den gesamten UI Ablauf zu ermšglichen. Einzig das Design fŸr eine Zelle der MessŸbersichtstabelle wurde in eine eigne XIB-Datei ausgelagert.

Die Anordnung der Controls wurde im Storyboard gelšst. Kleinere Merkmale wurden jeweils im Code angepasst, indem von bestehenden Controls abgeleitet wurde.

\subsection{Controllers}
\lstset{language=[Objective]C, breakindent=40pt, breaklines}

\subsubsection{Settings}

Einstellungen, welche pro Applikation verfŸgbar sein mŸssen, werden in den sogenannten UserDefaults gespeichert. Dieser Speicher, kann sŠmtliche serialisierbaren Objekte speichern.

\subsection{Components}
\subsection{View Store}
Der ViewStore dient wie der InstrumentStore zum speichern weiter benštigter Variablen. Er ist ebenfalls als Singleton implementiert. Im Gegensatz zum InstrumentStore enthŠlt der ViewStore aber nur Elemente, welche UI relevant sind. Darin wird beispielsweise gespeichert, ob gerade eine Aquire-Schleife lŠuft.
\subsection{Service}
\subsubsection{Validation}
FŸr die Validierung wurde von jedem benutzen Control eine Ableitung erstellt und das BaseValidationControl Protokoll implementiert. Dieses Protokoll enthŠlt ein Property isValid welches den GŸltikeitszustand des Objektes enthŠlt.
\newline\newline
Das Protokoll sieht wie folgt aus:

\begin{lstlisting}
protocol BaseValidationControl 
{
    var isValid : Bool {get}
    func validate()
}
\end{lstlisting}

Ein Beispiel fŸr die Implementierung des Protokolls ist das PortTextField:

\begin{lstlisting}
class PortTextField : BaseTextField 
{
    //Init Code
    
    override var isValid: Bool {
        get {
            let port = Int(text!)
            return port != nil && port! >= 0 && port! <= 65535
        }
    }
}
\end{lstlisting}

In jedem ViewController, muss nun nur noch der ValidationManager aufgerufen werden und die Hauptview Ÿbergeben werden. Dieser ValidationManager prŸft nun alle Subviews, welche das BaseValidationControl Protokoll implementieren.
Dieser Aufruf sieht folgendermassen fŸr die Validierung der gesamten View aus:
\begin{lstlisting}
ValidationManager.sharedInstance.validateSubViews(view: self.view)
\end{lstlisting}


\subsubsection{File Browser}
Der FileBrowser, ist eine Abwandlung von einer externen Swift Komponente, welche unter folgendem Link zu finden ist:
\newline
https://github.com/marmelroy/FileBrowser
\newline
Diese Komponente wurde auf die eignen BedŸrfnisse angepasst.
Der Filebrowser, besteht jeweils aus einem Container sowie einem embedded TableViewController. Zusammen bilden Sie ein einfaches System, in welchem der User ein File selektieren kann.
\newline
Der FileBrowser, kann einfach erweitert werden, indem ein neuer Container erstellt wird. Dieser Container muss von FileBrowserContainerViewController ableiten und kann diesen um neue Controls ergŠnzen. Um das Verhalten der inneren Tabelle zu Šndern, kann eine Klasse erstellt werden, welche von BaseFileBrowserTableViewController ableitet. Dies wird im Projekt bereits genutzt, um den Container mit der FunktionalitŠt der Ordnerwahl sowie der Ordnererstellung zu erweitern.

Folgend ein Beispiel, fŸr die Ordnerauswahl Ÿberschrieben wurde:

\begin{lstlisting}

class DirectoryBrowserContainerViewController : FileBrowserContainerViewController
{
    //Init
    
    @IBAction func ChooseDirectoryButtonClicked(_ sender: UIBarButtonItem) {
        didSelectFile!(DiskFile(url: selectedPath))
        dismiss(animated: true, completion: nil)
    }
}

class DirectoryBrowserTableViewController: FileBrowserTableViewController 
{
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let selectedFile = getFileForIndexPath(indexPath: indexPath)
        if(selectedFile.isDirectory)
        {
            // open folder
        }
        else
        {
            // deselect row
        }
    }
}
\end{lstlisting}

