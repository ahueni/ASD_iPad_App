\chapter{Umsetzung}
\section{Einleitung}
Dieses Kapitel beschreibt die Umsetzung des Produktes. Die nachfolgenden Abschnitte werden Schrittweise detaillierter und beschreiben den Aufbau sowie die Designentscheidungen des Softwarecodes. Es soll eine mšgliche Weiterentwicklung der Software ermšglichen und fŸr den Entwickler vereinfachen.

\section{Technologien}
In diesem Abschnitt wird beschrieben, welche Technologien und Tools eingesetzt wurden, um die iOS Applikation umzusetzen. Es wurde darauf geachtet, dass bewŠhrte und von Apple vorgesehene Technologien verwendet werden. Die Applikation sowie der Code entsprechen der von Apple vorgegebenen Richtlinien. Weitere Informationen fŸr die Entwicklung von Applikationen fŸr die iOS Betriebssysteme sind direkt im \href{https://developer.apple.com/develop/}{Apple Entwicklungsbereich} zu finden.

\subsection{Entwicklungsumgebung}
Das Projekt wurde mit XCode 8.2.1 umgesetzt. GrundsŠtzlich, kann jede \gls{ide} verwendet werden, welche mit Swift kompatibel ist. Die einzige Voraussetzung um die Applikation erfolgreich zu Kompilieren ist ein Computer mit macOS Betriebssystem.

Es kšnnen spŠter weitere Voraussetzungen dazukommen, je nachdem wie die Applikation an die tatsŠchlichen Benutzer ausgeliefert werden soll.

\subsection{Programmiersprache}
Das Projekt wurde in der Programmiersprache Swift 3 umgesetzt und ist mit iOS 10 und hšher kompatibel. Es wurde darauf geachtet, dass alle AbhŠngigkeiten ebenfalls in Swift umgesetzt sind. Dies erleichtert die Weiterentwicklung da kein, fŸr ungeŸbte Entwickler, meist schwer lesbarer Objective C Code zum Einsatz kommt.

\subsection{AbhŠngigkeiten}
Externe Ressourcen und Frameworks, wurden vorwiegend mit CocoaPods eingebunden. CocoaPods ist ein Paket Manager, mit welchem man Pakete in ein bestehendes Projekt einbinden kann. Dies geschieht Ÿber ein sogenanntes Podfile, welches zum Projektumfang gehšrt. Dieses File beschreibt die externen AbhŠngigkeiten, sowie welche Version benštigt wird. CocoaPods ist kein Produkt von Apple und wird durch die Community weiterentwickelt und bereitgestellt. Sollten Updates zu Frameworks bereitstehen kšnnen diese einfach ins Projekt integriert werden.

Folgende Frameworks wurden mit CocoaPods in das Projekt eingebunden und verwendet:
\begin{itemize}[noitemsep]
\item Charts: \href{https://github.com/danielgindi/Charts}{https://github.com/danielgindi/Charts}
\item Zip: \href{https://github.com/marmelroy/Zip}{https://github.com/marmelroy/Zip}
\item PlainPing: \href{https://github.com/naptics/PlainPing}{https://github.com/naptics/PlainPing}
\item Pulsator: \href{https://github.com/shu223/Pulsator}{https://github.com/shu223/Pulsator}
\item FontAwesome.swift: \href{https://github.com/thii/FontAwesome.swift}{https://github.com/thii/FontAwesome.swift}
\end{itemize}

Folgende Frameworks wurden direkt als Klassendateien ins Projekt eingebunden und verwendet, da sie nicht als Paket verfŸgbar sind.
\begin{itemize}[noitemsep]
\item Socks: \href{https://github.com/vapor/socks}{https://github.com/vapor/socks}
\end{itemize}

\subsection{Deployment}
Die Applikation wurde wŠhrend der Entwicklung mit dem von Apple zur verfŸgung gestellten Service \gls{testflight} ausgeliefert. Somit konnten die Prototypen und die Vorabversion auf einfache Art und Weise dem Kunden zur verfŸgung gestellt werden.

\gls{testflight} ermšglicht es Prototypen und Vorversionen Ÿber einen gesonderten AppStore auf registrierten iOS GerŠten von bis zu 200 Testpersonen als App-Download anzubieten. Um diesen Dienst zu Nutzen ist ein Apple Developer Account notwendig, mit der Integration und Konfiguration von zusŠtzlichen Zertifikaten.

FŸr eine zukŸnftige Weiterentwicklung und vor allem Auslieferung an externe Benutzer kann die Applikation ebenfalls in den AppStore aufgenommen werden oder als B2B\footnote{Develop Custom Apps for Business: \href{https://developer.apple.com/programs/volume/b2b/}{https://developer.apple.com/programs/volume/b2b/}} Applikation vertrieben werden. In beiden FŠllen benštigt der Entwickler aber einen gŸltigen Apple Developer Account.

\newpage

\section{Architektur}

\subsection{Grobarchitektur}
Um weite Teile des Quellcodes erneut nutzen zu kšnnen, wurde das Projekt in die drei Teile Core, Service und iOS App aufgeteilt. Die Layer wurden nach bestimmten Kriterien aufgetrennt, diese werden in den nachfolgenden Kapiteln genau beschrieben.

\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.3]{images/SA_BigPicture} 
	\caption{Layeraufteilung der Grobarchitektur}
	\label{fig:SALayers}
	\end{center}
\end{figure}

\subsection{Core}
Der Core fasst den gesamten Code zusammen welcher Platform unabhŠngig ist. Dieser Code kšnnten in weiteren Projekten eingesetzt werden die auf der Programmiersprache Swift aufbauen. Klassen im Core-Layer verwenden nur Grundkomponenten von Swift und kšnnte so auch auf einem anderen Betriebssystem eingesetzt werden das Swift unterstŸtzt.

\subsection{Service}
Der Service-Layer kapselt Anfragen des iOS-Layers an den Core. Dieser Layer wurde verwendet um ParallelitŠt zu vermeiden. Der Service-Layer beinhaltet Manager-Klassen die Aufrufe an den Core mit einer Synchronized-Queue bearbeiten und weiterleiten. Somit ist garantiert, dass niemals zwei Befehle gleichzeitig oder Ÿberlappend an das \gls{spectrometer} gesendet werden. Auch das Schreiben von nummerierten Messdateien ins Dateisystem kann durch ein FileManager so gekapselt werden.

Klassen im Service-Layer unterscheiden sich durch ein weiteres Kriterium vom Core. Sie kšnnen nur auf Plattformen von Apple eingesetzt werden, da sie gewisse Importe benštigen die nicht in der Swift Basis enthalten sind. Der Service-Layer kšnnte im gesamten Programmierumfeld von Apple (macOS, iOS, watchOS, tvOS) eingesetzt werden, nicht aber ausserhalb.

\subsection{iOS App}
Dieser Layer beinhaltet die eigentliche iOS App mit all ihren typischen Eigenschaften, wie das AppDelegate, die Storyboards und die ViewController. ZusŠtzlich wurden noch eigene ViewComponents erstellt die ebenfalls in diesem Layer enthalten sind.

\section{Core}

\subsection{Models}
In diesem Ordner werden sŠmtliche Datenstrukturen definiert die in Verbindung mit dem Spektrometer, den INI-Dateien oder Indico Dateien verwendet werden. Es wurde darauf geachtet diese mšglichst erweiterbar zu gestalten. Es gibt wenn mšglich eine Basis-Klasse die, die immer gleichen Grundstrukturen bei Spektraldaten oder Indico Dateien implementiert. Die Ableitungen spezialisieren dann die effektiven Datentypen.
Diese Aufteilung ermšglicht es einem Entwickler, einfach einen neuen Indico-Standart oder ein RŸckgabetyp eines zusŠtzlichen Spektrometers zu erstellen.

\subsubsection{Command}
Der Command wird verwendet um genormte Anfragen ans Spektrometer zu senden. FŸr jeden Command wurde eine Gršsse definiert die vom erwarteten Datentyp abhŠngt. Somit kann der TCP Manager jeweils entscheiden wann alle Daten empfangen wurden.

\subsubsection{SpectralData}
In diesem Ordner wurden alle Datentypen definiert die vom Spektrometer empfangen werden kšnnen. Die genauen Gršssen und vorhandenen Felder wurden dem ASD Developer Guide entnommen. Dieser ist im \color{red} Anhang \color{black} angehŠngt. Die meisten Befehle haben ihren bestimmten RŸckgabetyp einige verwandte Befehle verwenden jedoch auch den gleichen RŸckgabetyp.

\subsubsection{IndicoFile}
In diesem Ordner wurde der Datentyp fŸr das Indico Dateiformat definiert. Die Basisklasse \verb=IndicoFileBase= reprŠsentiert genau eine INI-Datei die fŸr die Spektrometer-Konfiguration verwendet wird. Die Ableitung \verb=IndicoFile7= reprŠsentiert die vollstŠndige Datei mit allen Spektraldaten. Der Inhalt der Dateien wird in der Abbildung \ref{fig:MeasurementFiles} genau dargestellt.

\subsection{Connections} \label{sec:connection}
In diesem Ordner, befindet sich die TCP-Manager Klasse sowie die externen Socks Dateien. Das Socks Framework kŸmmert sich um die Kommunikation auf TCP Ebene. FŸr die Integration wurde nicht CocoaPods verwendet deshalb wurden die Klassen direkt in den Ordner kopiert.

Der TCP-Manager ist fŸr die Anfragen an das Spektrometer verantwortlich. Es ist die einzige Klasse, welche direkt mit dem \gls{spectrometer} kommuniziert und ist deshalb als Singleton umgesetzt. Mit der Methode \verb=connect(internetAdress: InternetAddress)= kann eine Verbindung zum \gls{spectrometer} hergestellt werden, danach kšnnen beliebig viele Kommandos mit \verb=sendCommand(command: Command)= gesendet werden. Um die Verbindung zu schliessen, muss lediglich die \verb=disconnect()= Methode aufgerufen werden.

\subsection{Input/Output}
In diesem Kapitel werden alle Klassen beschrieben, welche direkt Dateien einlesen, Daten empfangen oder Dateien schreiben.

\subsubsection{File Writer}
Die Output Klassen, dienen dazu ein Indico File zu schreiben. Die Base Klasse kapselt dafŸr alle SchreibvorgŠnge. Von der Klasse File Writer, wird auf diese Methoden zugegriffen und stšsst so das Schreiben in der Richtigen Reihenfolge an. Von aussen kann lediglich gewŠhlt werden, welche der 3 Messmethoden geschrieben werden soll: Raw, Reflectance oder Radiance.
\newline
Um die Applikation um einen neuen Writer zu erweitern, muss lediglich vom BaseWriter abgeleitet werden und eine eigene write Methode implementiert werden. Diese neue Klasse, kann die vom BaseWriter bereitgestellten Methoden nutzen oder um weitere ergŠnzen.
\subsubsection{File Reader und Spectrometer Parser}
Die Reader- und Parserklassen bauen alle auf der selben Basis auf. In der \verb=BaseSpectrumInput= Klasse sind alle Funktionen realisiert um aus Byte Werten die entsprechenden Datentypen zu parsen. In den konkreten Implementierungen mŸssen diese dann nur in der richtigen Rheienfolge aufgerufen und den entsprechenden Feldern zugewiesen werden.

Durch die inkonsistente Impelmentierung von der Firma ASD gibt es immer wieder verwirrende stellen die gesondert implementiert werden mŸssen. Als Beispiele sind hier Strings zu nennen die zum Teil als prefixed, null-terminiert oder aber mit fixer LŠnge in der gleichen Datei implementiert wurden. Teilweise werden Float- oder Doublewerte in der selben Antwort vom GerŠt einmal im littleendian und dann wieder im bigendian Format codiert.

\subsection{Calculations}
Der Ordner Calculations enthŠlt lediglich die Klasse SpectrumCalculator welche nur statische Funktionen enthŠlt. Diese dienen der Berechnung der Reflektanz sowie der Radianz. Ausserdem beinhaltet die Klasse noch eine Methode um eine Dark Correction auf einem Ÿbergebenen Spetrum durchzufŸhren.
\subsection{Error Handling}

\section{Service}

\subsection{Instrument Store}
Im Instrument Store, werden alle Objekte gespeichert, auf welche global zugegriffen werden muss und nichts mit dem Userinterface zu tun haben. Um zu garantieren, dass die Variablen nur einmal existieren, ist die Klasse als Singleton umgesetzt.
\subsection{Command Manager}
Der Command Manager Ÿbernimmt die Funktion alle Kommandos in der korrekten Reihenfolge abzuarbeiten. Der Command Manager bietet Methoden fŸr alle gŠngigen \gls{spectrometer} Kommandos an. Wird eine dieser Methoden aufgerufen, Ÿbergibt der Command Manager die Anfrage an eine synchrone Queue welche nach dem First-In-First-Out Prinzip die Anfragen abarbeitet. So ist sichergestellt, dass ein Kommando erst an das \gls{spectrometer} gesendet wird, wenn alle vorherigen abgearbeitet sind.
\subsection{File Write Manager}
Der Write Manager funktioniert Šhnlich wie der Command Manager. Er Ÿbergibt write Anfragen ebenfalls einer synchronen Warteschlange und arbeitet diese ab. Dazu kŸmmert sich der FileWriteManager auch um die korrekte Benennung der ASD Files. Dies geschieht, indem er den hšchsten geschriebenen prefix eines Files im Pfad findet und diesen dan entsprechend erhšht.

\section{iOS App}
\subsection{App Delegate}
Das App Delegate ist das eigentliche Einstiegsfile jeder iOS Applikation. Darin wird beschrieben, wie der Prozess aus verschiednen ZustŠnden ablŠuft (Stopped, Paused, Notified). Im AppDelegate werden auch Applikationsweite DesignsŠnderungen vorgenommen, so wird beispielsweise die Schriftart fŸr die gesamte Applikation gesetzt.
\newline
AppDelegate wird ebenfalls aufgerufen, wenn ein File erfolgreich importiert wurde. Das importieren selbst, wird vom Betriebsystem Ÿbernommen. In diesem Projekt wird auf der aktuellen View eine Meldung angezeigt, dass ein File erfolgreich importiert wurde.
\subsection{Core Data}
Core Data ist ein System, um Daten auf dem GerŠt zu speichern, es dient nicht als Datenbank ersatz, kann aber fŸr einfache Speicherungen genutzt werden. Durch die Integration in XCode, lassen sich Speicherklassen einfach modellieren und einsetzen. Core Data Einstellungen kšnnen in xcdatamodeld Klassen vorgenommen werden. Dabei kšnnen Datentypen sowie die Relationen der einzelnen Records definiert werden. Weitere Informationen finden sich auf der offiziellen Entwicklerseite von Apple: https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/index.html

\begin{alertinfo}{Vorsicht}
	Core Data Zugriffe sind vergleichsweise langsam und sollten daher nicht in Schleifen verwendet werden.
\end{alertinfo}

\subsection{Views}

Alle ViewController sind in der Datei Main.storyboard enthalten. Dies war eine bewusste Entscheidung, um Entwicklern einen guten †berblick Ÿber den gesamten UI Ablauf zu ermšglichen. Einzig das Design fŸr eine Zelle der MessŸbersichtstabelle wurde in eine eigne XIB-Datei ausgelagert.

Die Anordnung der Controls wurde im Storyboard gelšst. Kleinere Merkmale wurden jeweils im Code angepasst, indem von bestehenden Controls abgeleitet wurde.

\subsection{Controllers}

\subsubsection{Connections}
Die zwei ViewControllers \verb=AddEditConnectionViewController= und \verb=ConnectionViewController= dienen beim Start der Applikation dazu neue Spektrometer hinzuzufŸgen oder bestehende zu bearbeiten. Diese ViewController interagieren direkt mit dem Storyboard und den dazugehšrigen Views. Die Klasse \verb=SpectrometerConfigTableViewCell= dient als Hilfsklasse um die TabelleneitrŠge der Spektrometertabelle zu gestalten und mit dem Code zu verknŸpfen.

\subsubsection{Spectrometer}

Der Ordner Spectrometer enthŠlt Klassen fŸr zwei wichtige Teile der Applikation. In der Klasse \verb=SpectrometerViewController= sind alle Funktionen und VerknŸpfungen fŸr die Hauptansicht umgesetzt. Diese ist in der Lage, wenn alle Voraussetzungen ErfŸllt sind, zwischen Raw, Reflectance und Radiance zu wechseln und die berechneten Daten direkt im Liniendiagramm darzustellen. Die kontinuierliche Aquisitation neuer Messwerte wird durch eine Endlosschlaufe immer weitergefŸhrt bis die Abbruchbedingung eintritt. Weiter ist die Klasse fŸr folgende Aktionen und Darstellungen zustŠndig:

\begin{itemize}[noitemsep]
\item Dark Current oder White Reference per Button auslšsen.
\item Die entsprechenden Timer wieder zurŸcksetzen und aktualisieren.
\item Messung initiieren, sprich die anzeige der PopUp View fŸr den Messablauf.
\item Verbindung zum Spektrometer trennen.
\end{itemize}

Im einem Unterordnern befindet sich zugleich die gesamte Logik um Messungen in vorgegebenen Messprotokollen auszufŸhren. Die Klassen sind zudem Verantwortlich die eingegebenen Messdaten zwischenzuspeichern und bei einer erneuten Messung bereits vorausgewŠhlt in den verschiedenen Komponenten (TextField, PathSelect, Switches, etc.) einzustellen.



\subsubsection{Measurements}

\subsubsection{Settings}

Einstellungen, welche pro Applikation verfŸgbar sein mŸssen, werden in den sogenannten UserDefaults gespeichert. Dieser Speicher, kann sŠmtliche serialisierbaren Objekte speichern.

\subsection{Components}
\subsection{View Store}
Der ViewStore dient wie der InstrumentStore zum speichern weiter benštigter Variablen. Er ist ebenfalls als Singleton implementiert. Im Gegensatz zum InstrumentStore enthŠlt der ViewStore aber nur Elemente, welche UI relevant sind. Darin wird beispielsweise gespeichert, ob gerade eine Aquire-Schleife lŠuft.
\subsection{Service}
\subsubsection{Validation}
FŸr die Validierung wurde von jedem benutzen Control eine Ableitung erstellt und das BaseValidationControl Protokoll implementiert. Dieses Protokoll enthŠlt ein Property isValid welches den GŸltikeitszustand des Objektes enthŠlt.
\newline\newline
Das Protokoll sieht wie folgt aus:

\begin{lstlisting}
protocol BaseValidationControl 
{
    var isValid : Bool {get}
    func validate()
}
\end{lstlisting}

Ein Beispiel fŸr die Implementierung des Protokolls ist das PortTextField:

\begin{lstlisting}
class PortTextField : BaseTextField 
{
    //Init Code
    
    override var isValid: Bool {
        get {
            let port = Int(text!)
            return port != nil && port! >= 0 && port! <= 65535
        }
    }
}
\end{lstlisting}

In jedem ViewController, muss nun nur noch der ValidationManager aufgerufen werden und die Hauptview Ÿbergeben werden. Dieser ValidationManager prŸft nun alle Subviews, welche das BaseValidationControl Protokoll implementieren.
Dieser Aufruf sieht folgendermassen fŸr die Validierung der gesamten View aus:
\begin{lstlisting}
ValidationManager.sharedInstance.validateSubViews(view: self.view)
\end{lstlisting}


\subsubsection{File Browser}
Der FileBrowser, ist eine Abwandlung von einer externen Swift Komponente, welche unter folgendem Link zu finden ist:
\newline
https://github.com/marmelroy/FileBrowser
\newline
Diese Komponente wurde auf die eignen BedŸrfnisse angepasst.
Der Filebrowser, besteht jeweils aus einem Container sowie einem embedded TableViewController. Zusammen bilden Sie ein einfaches System, in welchem der User ein File selektieren kann.
\newline
Der FileBrowser, kann einfach erweitert werden, indem ein neuer Container erstellt wird. Dieser Container muss von FileBrowserContainerViewController ableiten und kann diesen um neue Controls ergŠnzen. Um das Verhalten der inneren Tabelle zu Šndern, kann eine Klasse erstellt werden, welche von BaseFileBrowserTableViewController ableitet. Dies wird im Projekt bereits genutzt, um den Container mit der FunktionalitŠt der Ordnerwahl sowie der Ordnererstellung zu erweitern.

Folgend ein Beispiel, fŸr die Ordnerauswahl Ÿberschrieben wurde:

\begin{lstlisting}

class DirectoryBrowserContainerViewController : FileBrowserContainerViewController
{
    //Init
    
    @IBAction func ChooseDirectoryButtonClicked(_ sender: UIBarButtonItem) {
        didSelectFile!(DiskFile(url: selectedPath))
        dismiss(animated: true, completion: nil)
    }
}

class DirectoryBrowserTableViewController: FileBrowserTableViewController 
{
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let selectedFile = getFileForIndexPath(indexPath: indexPath)
        if(selectedFile.isDirectory)
        {
            // open folder
        }
        else
        {
            // deselect row
        }
    }
}
\end{lstlisting}

